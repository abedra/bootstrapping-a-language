#+TITLE:     Bootstrapping a Language
#+AUTHOR:    Aaron Bedra
#+EMAIL:     aaron@aaronbedra.com
#+LANGUAGE:  en

* Once upon a time there was a REPL				      :slide:
#+begin_src ruby
  #!/usr/bin/env ruby

  def repl
    while true
      "geeklisp> ".display
      puts gets
    end
  end

  repl
#+end_src
* But that REPL didn't do much					      :slide:
#+begin_src sh
  $ ./geeklisp
#+end_src
#+begin_src scheme
  geeklisp> (define foo 2)
  (define foo 2)
  geeklisp> (define bar 5)
  (define bar 5)
  geeklisp> (+ foo bar)
  (+ foo bar)
  geeklisp>
#+end_src
* This is the true story... of several lines of code... picked to live in a REPL... to work together and have their lines executed... find out what happens when code stops being polite... and starts getting real... :slide:
* Everyone should try to write a language			      :slide:
* 								      :slide:
file:lisplogo.png
* Peter Norvig							      :slide:
file:norvig.jpg
* The basics 							      :slide:
#+ATTR_HTML: border="2" rules="all" frame="border" align="center"
| Form               | Syntax                  | Example                           |
|--------------------+-------------------------+-----------------------------------|
| variable reference | =var=                   | =x=                               |
| constant literal   | =number=                | =12=                              |
| quoation           | =(quote exp)=           | =(quote (1 2 3))=                 |
| conditional        | =(if test conseq alt)=  | =(if (< 10 20) #t #f)=            |
| assignment         | =(set! var exp)=        | =(set! x (* x x))=                |
| definition         | =(define var exp)=      | =(define r 3)=                    |
| procedure          | =(lambda (var...) exp)= | =(lambda (r) (* r r)))=           |
| sequencing         | =(begin exp)=           | =(begin (set! x 1) (* x 2))=      |
| procedure call     | =(proc exp)=            | =(square 12)=                     |
* Let's start making our REPL into a real language		      :slide:
* Turning the lisp source into tokens (Read)			      :slide:
#+begin_src ruby
  def to_atom(src)
    return "[" if src =='('
    return "]" if src ==')'
    return src if src =~ /^-?\d+$/ || src =~ /^-?\d*\.\d+$/
    ':' + src
  end
  
  def read(src)
    tokens = src.gsub('(', ' ( ').gsub(')', ' ) ').split
    Kernel.eval(tokens.map{|s| to_atom(s)}.join(' ').gsub(' ]',']').gsub(/([^\[]) /,'\1, '))
  end
  
  def repl
    while true
      "geeklisp> ".display
      puts read(gets).inspect
    end
  end
#+end_src
* What it looks like						      :slide:
#+begin_src scheme
  $ ./geeklisp
  geeklisp> (+ 2 3)
  [:+, 2, 3]
  geeklisp> (define sqr (x) (* x x))
  [:define, :sqr, [:x], [:*, :x, :x]]
  geeklisp> (sqr 2)
  [:sqr, 2]
#+end_src
* Basic Evaluation						      :slide:
#+begin_src ruby
  def eval(x)
    return x if !x.is_a? Array
    case x[0]
      when :quote then x[1..-1]
    end
  end
  
  def repl
    while true
      "geeklisp> ".display
      puts (eval(read(gets))).inspect
    end
  end
#+end_src
* Did we take a step back? 					      :slide:
#+begin_src scheme
  $ ./geeklisp 
  geeklisp> (+ 2 3)
  nil
  geeklisp> (define sqr (x) (* x x))
  nil
  geeklisp> (sqr 4)
  nil
  geeklisp> (quote (1 2 3 4))
  [[1, 2, 3, 4]]
#+end_src
* We need a way to keep track of things so we can refer to them later :slide:
#+begin_src ruby
  class Env < Hash
    def initialize(keys=[], vals=[], outer=nil)
      @outer = outer
      keys.zip(vals).each{|p| store(*p)}
    end
  
    def [] (name)
      super(name) || @outer[name]
    end
  
    def set(name, value)
      key?(name) ? store(name, value) : @outer.set(name, value)
    end
  end
#+end_src
* Update eval to accept an env and repl to initialize an env 	      :slide:
#+begin_src ruby
  def eval(x, env)
    return env[x] if x.is_a? Symbol
    return x if !x.is_a? Array
    case x[0]
    when :quote then x[1..-1]
    when :define then env[x[1]] = eval(x[2], env)
    when :set! then env.set(x[1], eval(x[2], env))
    when :env then env
    end
  end
  
  def repl
    env = Env.new
    while true
      "geeklisp> ".display
      puts (eval(read(gets))).inspect
    end
  end
#+end_src
* Give it a try							      :slide:
#+begin_src scheme
  ./geeklisp 
  geeklisp> (define foo 5)
  5
  geeklisp> (define sqr (x) (* x x))
  nil
  geeklisp> (define bar 27)
  27
  geeklisp> foo
  5
  geeklisp> bar 
  27
  geeklisp> (define baz (quote (1 2 3)))
  [[1, 2, 3]]
  geeklisp> (env)
  {:foo=>5, :sqr=>nil, :bar=>27, :baz=>[[1, 2, 3]]}
#+end_src

#+TAGS: slide(s)

#+STYLE: <link rel="stylesheet" type="text/css" href="common.css" />
#+STYLE: <link rel="stylesheet" type="text/css" href="screen.css" media="screen" />
#+STYLE: <link rel="stylesheet" type="text/css" href="projection.css" media="projection" />
#+STYLE: <link rel="stylesheet" type="text/css" href="presenter.css" media="presenter" />

#+BEGIN_HTML
<script type="text/javascript" src="org-html-slideshow.js"></script>
#+END_HTML

# Local Variables:
# org-export-html-style-include-default: nil
# org-export-html-style-include-scripts: nil
# End:
