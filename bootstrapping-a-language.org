#+TITLE:     Bootstrapping a Language
#+AUTHOR:    Aaron Bedra
#+EMAIL:     aaron@aaronbedra.com
#+LANGUAGE:  en

* Once upon a time there was a REPL				      :slide:
#+begin_src ruby
  #!/usr/bin/env ruby

  def repl
    while true
      "geeklisp> ".display
      puts gets
    end
  end

  repl
#+end_src
* But that REPL didn't do much					      :slide:
#+begin_src sh
  $ ./geeklisp
#+end_src
#+begin_src scheme
  geeklisp> (define foo 2)
  (define foo 2)
  geeklisp> (define bar 5)
  (define bar 5)
  geeklisp> (+ foo bar)
  (+ foo bar)
  geeklisp>
#+end_src
* This is the true story... of several lines of code... picked to live in a REPL... to work together and have their lines executed... find out what happens when code stops being polite... and starts getting real... :slide:
* Everyone should try to write a language			      :slide:
* 								      :slide:
file:lisplogo.png
* Peter Norvig							      :slide:
file:norvig.jpg
* The basics 							      :slide:
#+ATTR_HTML: border="2" rules="all" frame="border" align="center"
| Form               | Syntax                  | Example                           |
|--------------------+-------------------------+-----------------------------------|
| variable reference | =var=                   | =x=                               |
| constant literal   | =number=                | =12=                              |
| quoation           | =(quote exp)=           | =(quote (1 2 3))=                 |
| conditional        | =(if test conseq alt)=  | =(if (< 10 20) #t #f)=            |
| assignment         | =(set! var exp)=        | =(set! x (* x x))=                |
| definition         | =(define var exp)=      | =(define r 3)=                    |
| procedure          | =(lambda (var...) exp)= | =(lambda (r) (* r r)))=           |
| sequencing         | =(begin exp)=           | =(begin (set! x 1) (* x 2))=      |
| procedure call     | =(proc exp)=            | =(square 12)=                     |
* Let's start making our REPL into a real language		      :slide:
* Turning the lisp source into tokens (Read)			      :slide:
#+begin_src ruby
  def to_atom(src)
    return "[" if src =='('
    return "]" if src ==')'
    return src if src =~ /^-?\d+$/ || src =~ /^-?\d*\.\d+$/
    ':' + src
  end

  def read(src)
    tokens = src.gsub('(', ' ( ').gsub(')', ' ) ').split
    Kernel.eval(tokens.map{|s| to_atom(s)}.join(' ').gsub(' ]',']').gsub(/([^\[]) /,'\1, '))
  end

  def repl
    while true
      "geeklisp> ".display
      puts read(gets).inspect
    end
  end
#+end_src
* What it looks like						      :slide:
#+begin_src scheme
  $ ./geeklisp
  geeklisp> (+ 2 3)
  [:+, 2, 3]
  geeklisp> (define sqr (x) (* x x))
  [:define, :sqr, [:x], [:*, :x, :x]]
  geeklisp> (sqr 2)
  [:sqr, 2]
#+end_src
* Basic Evaluation						      :slide:
#+begin_src ruby
  def eval(x)
    return x if !x.is_a? Array
    case x[0]
      when :quote then x[1..-1]
    end
  end

  def repl
    while true
      "geeklisp> ".display
      puts (eval(read(gets))).inspect
    end
  end
#+end_src
* Did we take a step back? 					      :slide:
#+begin_src scheme
  $ ./geeklisp
  geeklisp> (+ 2 3)
  nil
  geeklisp> (define sqr (x) (* x x))
  nil
  geeklisp> (sqr 4)
  nil
  geeklisp> (quote (1 2 3 4))
  [[1, 2, 3, 4]]
#+end_src
* We need a way to keep track of things so we can refer to them later :slide:
#+begin_src ruby
  class Env < Hash
    def initialize(keys=[], vals=[], outer=nil)
      @outer = outer
      keys.zip(vals).each{|p| store(*p)}
    end

    def [] (name)
      super(name) || @outer[name]
    end

    def set(name, value)
      key?(name) ? store(name, value) : @outer.set(name, value)
    end
  end
#+end_src
* Update eval to accept an env and repl to initialize an env 	      :slide:
#+begin_src ruby
  def eval(x, env)
    return env[x] if x.is_a? Symbol
    return x if !x.is_a? Array
    case x[0]
    when :quote then x[1..-1]
    when :define then env[x[1]] = eval(x[2], env)
    when :set! then env.set(x[1], eval(x[2], env))
    when :env then env
    end
  end

  def repl
    env = Env.new
    while true
      "geeklisp> ".display
      p(eval(read(gets), env))
    end
  end
#+end_src
* Give it a try							      :slide:
#+begin_src scheme
  ./geeklisp
  geeklisp> (define foo 5)
  5
  geeklisp> (define sqr (x) (* x x))
  nil
  geeklisp> (define bar 27)
  27
  geeklisp> foo
  5
  geeklisp> bar
  27
  geeklisp> (define baz (quote (1 2 3)))
  [[1, 2, 3]]
  geeklisp> (env)
  {:foo=>5, :sqr=>nil, :bar=>27, :baz=>[[1, 2, 3]]}
#+end_src
* But our language still doesn't really know how to do anything...    :slide:
#+begin_src scheme
  $ ./geeklisp
  geeklisp> (+ 2 3)
  nil
  geeklisp> (car (1 2 3))
  nil
  geeklisp> (cdr (1 2 3))
  nil
  geeklisp> (+ (* 3 4) 5)
  nil
#+end_src
* Define the basic primitives					      :slide:
#+begin_src ruby
  def init(env)
    [:+, :-, :*, :/, :>, :<, :>=, :<=, :==].each do |op|
      env[op] = lambda{|a, b| a.send(op, b)}
    end
  end

  def repl
    env = init(Env.new)
    while true
      "geeklisp> ".display
      p(eval(read(gets), env))
    end
  end

  def eval(x, env)
    ...
    else
      exps = x.map{|exp| eval(exp, env)}
      exps[0].call(*exps[1..-1])
    end
  end
#+end_src
* Now we're cooking						      :slide:
#+begin_src scheme
  $ ./geeklisp
  geeklisp> (* 2 3)
  6
  geeklisp> (> 2 3)
  false
  geeklisp> (< 2 3)
  true
  geeklisp> (/ 4 12)
  0
  geeklisp> (/ 12 4)
  3
  geeklisp> (- 5 6)
  -1
  geeklisp> (== 5 5)
  true
#+end_src
* Bootstrapping more basic functions				      :slide:
#+begin_src ruby
  def init(env)
    [:+, :-, :*, :/, :>, :<, :>=, :<=, :==].each do |op|
      env[op] = lambda{|a, b| a.send(op, b)}
    end
    env.update({ :length => lambda{|x| x.length}, :cons => lambda{|x, y| [x]+y},
    :car => lambda{|x| x[0]}, :cdr => lambda{|x| x[1..-1]}, :append => lambda{|x,y| x+y},
    :list => lambda{|*xs| xs}, :list? => lambda{|x| x.is_a? Array}, :null? => lambda{|x| x==nil},
    :symbol? => lambda{|x| x.is_a? Symbol}, :not => lambda{|x| !x}, :display => lambda{|x| p x}})
  end
#+end_src
* Try it out							      :slide:
#+begin_src scheme
  (define foo (list 1 2 3))
  [1, 2, 3]
  geeklisp> (car foo)
  1
  geeklisp> (cdr foo)
  [2, 3]
  geeklisp> (cons 4 foo)
  [4, 1, 2, 3]
  geeklisp> (list? foo)
  true
  geeklisp> (define bar 5)
  5
  geeklisp> (list? 5)
  false
#+end_src
* We're almost there! Let's round things out			      :slide:
#+begin_src ruby
  def eval(x, env)
    return env[x] if x.is_a? Symbol
    return x if !x.is_a? Array
    case x[0]
    when :quote then x[1..-1]
    when :define then env[x[1]] = eval(x[2], env)
    when :set! then env.set(x[1], eval(x[2], env))
    when :env then env
    when :if
        _, test, conseq, alt = x
      eval(eval(test, env) ? conseq : alt, env)
    when :lambda
      _, vars, exp = x
      Proc.new{|*args| eval(exp, Env.new(vars, args, env))}
    when :begin
      x[1..-1].reduce([nil, env]){|val_env, exp| [eval(exp, val_env[1]), val_env[1]]}[0]
    else
      exps = x.map{|exp| eval(exp, env)}
      exps[0].call(*exps[1..-1])
    end
  end
#+end_src
* Take in your new awesomeness					      :slide:
#+begin_src scheme
  $ ./geeklisp
  geeklisp> (if (< 3 5) 10 20)
  10
  geeklisp> (if (> 3 5) 10 20)
  20
  geeklisp> (define square (lambda (x) (* x x)))
  #<Proc:0x00000001001b7aa0@./geeklisp:41>
  geeklisp> (square 12)
  144
  geeklisp> (begin (set! x 1) (set! x (+ x 1)) (* x 2))
  4
#+end_src

#+TAGS: slide(s)

#+STYLE: <link rel="stylesheet" type="text/css" href="common.css" />
#+STYLE: <link rel="stylesheet" type="text/css" href="screen.css" media="screen" />
#+STYLE: <link rel="stylesheet" type="text/css" href="projection.css" media="projection" />
#+STYLE: <link rel="stylesheet" type="text/css" href="presenter.css" media="presenter" />

#+BEGIN_HTML
<script type="text/javascript" src="org-html-slideshow.js"></script>
#+END_HTML

# Local Variables:
# org-export-html-style-include-default: nil
# org-export-html-style-include-scripts: nil
# End:
